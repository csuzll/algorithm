题目：
输入n个整数，找出其中最小的k个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。

思路：
1、最简单的方法就是全排序，然后遍历输出前K个数。时间复杂度为O(nlogn)

2、
基于快速排序中的partition函数，时间复杂度为O（n），空间复杂度为O（1）；需要改变输入；
（1）根据Partition函数得到索引值index，index前的数据均小于nums[index]，index后的数据均大于nums[index]
（2）如果index = k-1，则已经划分完成；数组前k个数据即为最小的k个数
（3）如果index>k-1，begin=index+1；否则end = index-1
（4）重复（2）操作直到index = k-1

3、
数字非常的多，一次性将其载入内存变得不可能或者内存消耗过大，那上面的方法就不再可行。
动态维护大小为k的堆，时间复杂度为O（nlogk），空间复杂度为O（k），无需改变输入；

具体步骤：
（1）将数列的前K个数存储
（2）从第K+1个数开始遍历数组：
（3）将前K个数构造为最大堆，并且排序。
（4）如果插入的数比最大值小，就将其替换最大值。然后重新构造，重新排序。
